Question 3:
    Implémentation de la fonction : void freeTokenQueue(ptrQueue* q)
qui permet de de libérer l'ensemble des ressources allouées (y compris celles à l'extérieur
du gestionnaire de collection). Afin de respecter les propriétés de l'interface privée, on utilise seulement les fonctions
fournies par l'interface publique du gestionnaire de collection (ici le module Queue). Dans la fonction computeExpressions,
on appelle freeTokenQueue lorsque le traitement sur une ligne est terminé.


Fonction getTopAndPop(s) permet d'éviter la redondance de code:
Token* t = (Token*)stackTop(s);
s = stackPop(s);
où le cast permet de s'assurer que la cellule contenant le top dont la valeur est un type void*
sera bien convertie en type Token

Fonction freeTokenQueue(q) utilisée pour la partie 1 puis plus utilisée par la suite.
En effet, contrairement à la fonction stringToTokenQueue qui renvoie une file de token,
la fonction shunting yard s'assure que la file de tokens en parcours infixe est vide.
De même, la fonction evaluateExpression s'assure que la file de tokens en parcours postfixe
est vide également. Cela signifie que toutes les ressources allouées à l'extérieur du gestionnaire
de collection ont déjà été libérées naturellement par les algorithmes. Il suffit d'utiliser les fonctions
delete des modules.

Pour libérer les ressources utilisées par les algorithmes, il y a deux possibilités.
Soit les libérer à l'intérieur de la fonction qui fait le traitement, soit les libérer dans la fonction
computeExpressions. J'ai choisi la deuxième option. En effet, on pourrait imaginer rassembler l'ensemble des fonctions
programmées dans un module de traitement de tokens. Dans ce cas là, il est préférable que l'utilisateur
maîtrise autant que possible l'allocation dynamique des ressources.

Dans la fonction stringToTokenQueue, le cas "curpos == ' ' ou curpos == '\n' est inclus
dans le test !isSymbol(*curpos) && !isNumValue(*curpos). Cela assure que tout caractère invalide sera ignoré.